name: Production Deployment - Revamp 2.0

on:
  push:
    branches: [main]
    paths-ignore:
      - "docs/**"
      - "*.md"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  PROJECT_ID: noelmc
  REGION: us-central1
  REPOSITORY: izerwaren-revamp-2-0
  WEB_SERVICE: izerwaren-revamp-2-0-web
  API_SERVICE: izerwaren-revamp-2-0-api

jobs:
  # Job 1: Build and Push Images to Artifact Registry
  build-and-push:
    name: Build & Push to Artifact Registry
    runs-on: ubuntu-latest
    outputs:
      web-image: ${{ steps.build-meta.outputs.web-image }}
      api-image: ${{ steps.build-meta.outputs.api-image }}
      build-tag: ${{ steps.build-meta.outputs.build-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: Generate build metadata
        id: build-meta
        run: |
          VERSION_TAG=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BUILD_TAG="${TIMESTAMP}-${VERSION_TAG}"

          WEB_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/izerwaren-revamp-2-0-web"
          API_IMAGE="${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/izerwaren-revamp-2-0-api"

          echo "build-tag=${BUILD_TAG}" >> $GITHUB_OUTPUT
          echo "web-image=${WEB_IMAGE}:${BUILD_TAG}" >> $GITHUB_OUTPUT
          echo "api-image=${API_IMAGE}:${BUILD_TAG}" >> $GITHUB_OUTPUT

          echo "Build tag: ${BUILD_TAG}"
          echo "Web image: ${WEB_IMAGE}:${BUILD_TAG}"
          echo "API image: ${API_IMAGE}:${BUILD_TAG}"

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          target: production
          push: true
          tags: |
            ${{ steps.build-meta.outputs.web-image }}
            ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/izerwaren-revamp-2-0-web:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      # TODO: Add backend image build when Dockerfile.backend exists
      # - name: Build and push backend image
      #   if: hashFiles('Dockerfile.backend') != ''
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: .
      #     file: ./Dockerfile.backend
      #     target: production
      #     push: true
      #     tags: |
      #       ${{ steps.build-meta.outputs.api-image }}
      #       ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/izerwaren-revamp-2-0-api:latest
      #     cache-from: type=gha
      #     cache-to: type=gha,mode=max
      #     platforms: linux/amd64,linux/arm64

      - name: Save build metadata
        run: |
          cat > build-metadata.json << EOF
          {
            "buildTime": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "buildTag": "${{ steps.build-meta.outputs.build-tag }}",
            "gitCommit": "$(git rev-parse HEAD)",
            "gitBranch": "$(git rev-parse --abbrev-ref HEAD)",
            "images": {
              "frontend": "${{ steps.build-meta.outputs.web-image }}",
              "backend": "${{ steps.build-meta.outputs.api-image }}"
            }
          }
          EOF

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-metadata
          path: build-metadata.json

  # Job 2: Deploy to Cloud Run (Blue-Green)
  deploy:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    needs: build-and-push
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: https://${{ env.WEB_SERVICE }}-uc.a.run.app

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build metadata
        uses: actions/download-artifact@v5
        with:
          name: build-metadata

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Make deployment scripts executable
        run: |
          chmod +x scripts/deployment/*.sh

      - name: Deploy with Blue-Green Strategy
        run: |
          BUILD_TAG=$(jq -r '.buildTag' build-metadata.json)

          echo "ðŸš€ Starting blue-green deployment with tag: ${BUILD_TAG}"

          # Use our comprehensive blue-green deployment script
          ./scripts/deployment/deploy-blue-green.sh \
            --tag "${BUILD_TAG}" \
            --skip-build

      - name: Save deployment metadata
        run: |
          BUILD_TAG=$(jq -r '.buildTag' build-metadata.json)

          cat > deployment-metadata.json << EOF
          {
            "deploymentTime": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "buildTag": "${BUILD_TAG}",
            "environment": "${{ github.event.inputs.environment || 'production' }}",
            "services": {
              "frontend": {
                "name": "${{ env.WEB_SERVICE }}",
                "url": "https://${{ env.WEB_SERVICE }}-$(echo ${{ env.REGION }} | tr -d '-')-uc.a.run.app"
              }
            }
          }
          EOF

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-metadata
          path: deployment-metadata.json

  # Job 3: Configure Custom Domain (if production)
  configure-domain:
    name: Configure Custom Domain
    runs-on: ubuntu-latest
    needs: deploy
    if: github.event.inputs.environment == 'production' || (github.event.inputs.environment == '' && github.ref == 'refs/heads/main')

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure domain mapping
        run: |
          # Check if domain mapping already exists
          if ! gcloud run domain-mappings describe izerwaren.mcmichaelbuild.com --region=${{ env.REGION }} > /dev/null 2>&1; then
            echo "Creating domain mapping for izerwaren.mcmichaelbuild.com"
            gcloud run domain-mappings create \
              --service=${{ env.WEB_SERVICE }} \
              --domain=izerwaren.mcmichaelbuild.com \
              --region=${{ env.REGION }}
          else
            echo "Domain mapping already exists, updating service reference"
            gcloud run domain-mappings update izerwaren.mcmichaelbuild.com \
              --service=${{ env.WEB_SERVICE }} \
              --region=${{ env.REGION }}
          fi

      - name: Display DNS configuration
        run: |
          echo "ðŸ“‹ DNS Configuration Required:"
          echo "Create the following DNS record:"
          echo "Name: izerwaren.mcmichaelbuild.com"
          echo "Type: CNAME"
          echo "Value: ghs.googlehosted.com"
          echo ""
          echo "Or check current domain status:"
          gcloud run domain-mappings describe izerwaren.mcmichaelbuild.com --region=${{ env.REGION }}

  # Job 4: Post-Deployment Verification
  verify:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: [deploy, configure-domain]
    if: always() && needs.deploy.result == 'success'

    steps:
      - name: Download deployment metadata
        uses: actions/download-artifact@v5
        with:
          name: deployment-metadata

      - name: Verify deployment
        run: |
          FRONTEND_URL=$(jq -r '.services.frontend.url' deployment-metadata.json)

          echo "ðŸ” Verifying deployment at: ${FRONTEND_URL}"

          # Test the main service URL
          for i in {1..3}; do
            if curl -sf "${FRONTEND_URL}" > /dev/null; then
              echo "âœ… Service is responding correctly"
              break
            else
              echo "âŒ Service verification failed (attempt $i/3)"
              if [ $i -eq 3 ]; then
                echo "Service verification failed after 3 attempts"
                exit 1
              fi
              sleep 30
            fi
          done

      - name: Run smoke tests
        run: |
          FRONTEND_URL=$(jq -r '.services.frontend.url' deployment-metadata.json)

          echo "ðŸ§ª Running smoke tests..."

          # Test critical endpoints
          curl -sf "${FRONTEND_URL}" > /dev/null || exit 1
          curl -sf "${FRONTEND_URL}/catalog" > /dev/null || exit 1

          echo "âœ… Smoke tests passed"

      - name: Cleanup old revisions
        run: |
          echo "ðŸ§¹ Cleaning up old revisions (keeping last 5)..."

          # Keep only the last 5 revisions for the frontend service
          gcloud run revisions list \
            --service=${{ env.WEB_SERVICE }} \
            --region=${{ env.REGION }} \
            --format="value(metadata.name)" \
            --sort-by="~metadata.creationTimestamp" \
            --limit=100 | tail -n +6 | while read revision; do
              if [ -n "$revision" ]; then
                echo "Deleting old revision: $revision"
                gcloud run revisions delete "$revision" --region=${{ env.REGION }} --quiet || true
              fi
            done

  # Job 5: Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy, configure-domain, verify]
    if: always()

    steps:
      - name: Download deployment metadata
        if: needs.deploy.result == 'success'
        uses: actions/download-artifact@v5
        with:
          name: deployment-metadata

      - name: Prepare notification
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            STATUS="âœ… SUCCESS"
            COLOR="good"
            if [ -f deployment-metadata.json ]; then
              FRONTEND_URL=$(jq -r '.services.frontend.url' deployment-metadata.json)
              BUILD_TAG=$(jq -r '.buildTag' deployment-metadata.json)
              MESSAGE="Deployment successful!\nFrontend: ${FRONTEND_URL}\nBuild: ${BUILD_TAG}"
            else
              MESSAGE="Deployment completed successfully"
            fi
          else
            STATUS="âŒ FAILED"
            COLOR="danger"
            MESSAGE="Deployment failed. Check logs for details."
          fi

          echo "STATUS=${STATUS}" >> $GITHUB_ENV
          echo "COLOR=${COLOR}" >> $GITHUB_ENV
          echo "MESSAGE=${MESSAGE}" >> $GITHUB_ENV

      - name: Notify via Slack
        if: env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "${{ env.STATUS }} - Izerwaren Revamp 2.0 Deployment",
              attachments: [{
                color: "${{ env.COLOR }}",
                fields: [{
                  title: "Environment",
                  value: "${{ github.event.inputs.environment || 'production' }}",
                  short: true
                }, {
                  title: "Commit",
                  value: "${{ github.sha }}",
                  short: true
                }, {
                  title: "Details",
                  value: "${{ env.MESSAGE }}",
                  short: false
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const deployment_id = context.payload.deployment?.id;

            if (deployment_id) {
              await github.rest.repos.createDeploymentStatus({
                owner,
                repo,
                deployment_id,
                state: '${{ needs.deploy.result }}' === 'success' ? 'success' : 'failure',
                description: '${{ env.MESSAGE }}',
                environment_url: '${{ needs.deploy.result }}' === 'success' ? 'https://izerwaren.mcmichaelbuild.com' : undefined
              });
            }
